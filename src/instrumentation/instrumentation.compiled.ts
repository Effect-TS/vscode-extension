/* eslint-disable @effect/dprint */
export const compiledInstrumentationString = "(function(){ var Array = globalThis.Array; var Object = globalThis.Object; var String = globalThis.String; \nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\n(function() {\n    'use strict';\n    // src/instrumentation/shims.ts\n    var CounterStateSymbolKey = \"effect/MetricState/Counter\";\n    var CounterStateTypeId = Symbol.for(CounterStateSymbolKey);\n    var FrequencyStateSymbolKey = \"effect/MetricState/Frequency\";\n    var FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey);\n    var GaugeStateSymbolKey = \"effect/MetricState/Gauge\";\n    var GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey);\n    var HistogramStateSymbolKey = \"effect/MetricState/Histogram\";\n    var HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey);\n    var SummaryStateSymbolKey = \"effect/MetricState/Summary\";\n    var SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey);\n    var isCounterState = function(u) {\n        return (typeof u === \"undefined\" ? \"undefined\" : _type_of(u)) === \"object\" && u !== null && CounterStateTypeId in u;\n    };\n    var isFrequencyState = function(u) {\n        return (typeof u === \"undefined\" ? \"undefined\" : _type_of(u)) === \"object\" && u !== null && FrequencyStateTypeId in u;\n    };\n    var isGaugeState = function(u) {\n        return (typeof u === \"undefined\" ? \"undefined\" : _type_of(u)) === \"object\" && u !== null && GaugeStateTypeId in u;\n    };\n    var isHistogramState = function(u) {\n        return (typeof u === \"undefined\" ? \"undefined\" : _type_of(u)) === \"object\" && u !== null && HistogramStateTypeId in u;\n    };\n    var isSummaryState = function(u) {\n        return (typeof u === \"undefined\" ? \"undefined\" : _type_of(u)) === \"object\" && u !== null && SummaryStateTypeId in u;\n    };\n    var globalMetricRegistrySymbol = Symbol.for(\"effect/Metric/globalMetricRegistry\");\n    function globalStores() {\n        return Object.keys(globalThis).filter(function(key) {\n            return key.indexOf(\"effect/GlobalValue/globalStoreId\") > -1 || key === \"effect/GlobalValue\";\n        }).map(function(key) {\n            return globalThis[key];\n        });\n    }\n    function getOrUndefined(option) {\n        return option._tag === \"Some\" ? option.value : void 0;\n    }\n    var Interruption = 1 << 0;\n    var WindDown = 1 << 4;\n    var isEnabled = function(self, flag) {\n        return (self & flag) !== 0;\n    };\n    var interruptible = function(self) {\n        return isEnabled(self, Interruption) && !isEnabled(self, WindDown);\n    };\n    // src/instrumentation/instrumentation.ts\n    var _globalThis = globalThis;\n    var instrumentationKey = \"effect/devtools/instrumentation\";\n    var instrumentationId = Math.random().toString(36).substring(2, 15);\n    function addSetInterceptor(obj, key, interceptor) {\n        var previousProperty = Object.getOwnPropertyDescriptor(obj, key);\n        if (previousProperty && previousProperty.set) {\n            Object.defineProperty(obj, key, {\n                \"value\": previousProperty.value,\n                \"writable\": previousProperty.writable,\n                \"enumerable\": previousProperty.enumerable,\n                \"configurable\": previousProperty.configurable,\n                \"get\": previousProperty.get,\n                \"set\": function(_) {\n                    var _previousProperty_set;\n                    interceptor(_);\n                    (_previousProperty_set = previousProperty.set) === null || _previousProperty_set === void 0 ? void 0 : _previousProperty_set.bind(this)(_);\n                }\n            });\n        } else {\n            var _val;\n            Object.defineProperty(obj, key, {\n                \"set\": function(_) {\n                    _val = _;\n                    interceptor(_);\n                },\n                \"get\": function() {\n                    return _val;\n                }\n            });\n        }\n    }\n    function metricsSnapshot() {\n        var metrics = [];\n        var stores = globalStores();\n        for(var i = 0; i < stores.length; i++){\n            var store = stores[i];\n            var metricRegistry = store.get(globalMetricRegistrySymbol);\n            if (!metricRegistry) continue;\n            var snapshot = metricRegistry.snapshot();\n            for(var i2 = 0, len = snapshot.length; i2 < len; i2++){\n                var metricPair = snapshot[i2];\n                if (isCounterState(metricPair.metricState)) {\n                    metrics.push({\n                        \"_tag\": \"Counter\",\n                        \"name\": metricPair.metricKey.name,\n                        \"description\": getOrUndefined(metricPair.metricKey.description),\n                        \"tags\": metricPair.metricKey.tags,\n                        \"state\": {\n                            \"count\": _type_of(metricPair.metricState.count) === \"bigint\" ? metricPair.metricState.count.toString() : metricPair.metricState.count\n                        }\n                    });\n                } else if (isGaugeState(metricPair.metricState)) {\n                    metrics.push({\n                        \"_tag\": \"Gauge\",\n                        \"name\": metricPair.metricKey.name,\n                        \"description\": getOrUndefined(metricPair.metricKey.description),\n                        \"tags\": metricPair.metricKey.tags,\n                        \"state\": {\n                            \"value\": _type_of(metricPair.metricState.value) === \"bigint\" ? metricPair.metricState.value.toString() : metricPair.metricState.value\n                        }\n                    });\n                } else if (isHistogramState(metricPair.metricState)) {\n                    metrics.push({\n                        \"_tag\": \"Histogram\",\n                        \"name\": metricPair.metricKey.name,\n                        \"description\": getOrUndefined(metricPair.metricKey.description),\n                        \"tags\": metricPair.metricKey.tags,\n                        \"state\": metricPair.metricState\n                    });\n                } else if (isSummaryState(metricPair.metricState)) {\n                    metrics.push({\n                        \"_tag\": \"Summary\",\n                        \"name\": metricPair.metricKey.name,\n                        \"description\": getOrUndefined(metricPair.metricKey.description),\n                        \"tags\": metricPair.metricKey.tags,\n                        \"state\": metricPair.metricState\n                    });\n                } else if (isFrequencyState(metricPair.metricState)) {\n                    metrics.push({\n                        \"_tag\": \"Frequency\",\n                        \"name\": metricPair.metricKey.name,\n                        \"description\": getOrUndefined(metricPair.metricKey.description),\n                        \"tags\": metricPair.metricKey.tags,\n                        \"state\": {\n                            \"occurrences\": Object.fromEntries(metricPair.metricState.occurrences.entries())\n                        }\n                    });\n                }\n            }\n        }\n        return {\n            \"_tag\": \"MetricsSnapshot\",\n            \"metrics\": metrics\n        };\n    }\n    function convertExternalSpan(span) {\n        return {\n            \"_tag\": \"ExternalSpan\",\n            \"traceId\": span.traceId,\n            \"spanId\": span.spanId,\n            \"sampled\": span.sampled\n        };\n    }\n    function getSpanStack(span) {\n        var stackString = globalStores().reduce(function(acc, store) {\n            if (acc || !store) return acc;\n            var spanToTrace = store.get(\"effect/Tracer/spanToTrace\");\n            var stackFn = spanToTrace ? spanToTrace.get(span) : acc;\n            return stackFn ? stackFn() : acc;\n        }, void 0) || \"\";\n        var stack = stackString.split(\"\\n\").filter(function(_) {\n            return String(_).length > 0;\n        });\n        var out = [];\n        for(var i = 0; i < stack.length; i++){\n            var line = stack[i];\n            var match = line.match(/^at (.*) \\((.*):(\\d+):(\\d+)\\)$/);\n            if (match) {\n                out.push({\n                    \"path\": match[2],\n                    \"line\": parseInt(match[3]) - 1,\n                    \"column\": parseInt(match[4]) - 1\n                });\n            } else {\n                var matchOnlyAt = line.match(/^at (.*):(\\d+):(\\d+)$/);\n                if (matchOnlyAt) {\n                    out.push({\n                        \"path\": matchOnlyAt[1],\n                        \"line\": parseInt(matchOnlyAt[2]) - 1,\n                        \"column\": parseInt(matchOnlyAt[3]) - 1\n                    });\n                }\n            }\n        }\n        return out;\n    }\n    function convertSpan(span) {\n        var stack = getSpanStack(span);\n        return {\n            \"_tag\": \"Span\",\n            \"spanId\": span.spanId,\n            \"traceId\": span.traceId,\n            \"name\": span.name,\n            \"sampled\": span.sampled,\n            \"status\": span.status._tag === \"Started\" ? {\n                _tag: \"Started\",\n                \"startTime\": String(span.status.startTime)\n            } : {\n                _tag: \"Ended\",\n                \"startTime\": String(span.status.startTime),\n                \"endTime\": String(span.status.endTime)\n            },\n            \"parent\": span.parent._tag === \"None\" ? span.parent : {\n                _tag: \"Some\",\n                \"value\": convertAnySpan(span.parent.value)\n            },\n            \"attributes\": Array.from(span.attributes.entries()).concat(stack.length > 0 ? [\n                [\n                    \"@effect/devtools/trace\",\n                    \"at \" + span.name + \" (\" + stack[0].path + \":\" + (stack[0].line + 1) + \":\" + (stack[0].column + 1) + \")\"\n                ]\n            ] : [])\n        };\n    }\n    function convertAnySpan(span) {\n        if (span._tag === \"ExternalSpan\") {\n            return convertExternalSpan(span);\n        }\n        return convertSpan(span);\n    }\n    if (!(instrumentationKey in globalThis)) {\n        var addTrackedFiber = function addTrackedFiber(fiber) {\n            if (fibers.indexOf(fiber) === -1) {\n                if (hasDevtoolsConnected) addTracerInterceptorToFiber(fiber);\n                fibers.push(fiber);\n                fiber.addObserver(function() {\n                    var index = fibers.indexOf(fiber);\n                    if (index > -1) {\n                        fibers.splice(index, 1);\n                    }\n                });\n            }\n        }, debugProtocolDevtoolsClient = function debugProtocolDevtoolsClient(requests) {\n            if (!hasDevtoolsConnected) {\n                hasDevtoolsConnected = true;\n                fibers.forEach(addTracerInterceptorToFiber);\n            }\n            var processedRequestTypes = [];\n            for(var i = 0; i < requests.length; i++){\n                var request = requests[i];\n                switch(request._tag){\n                    case \"Pong\":\n                        continue;\n                    case \"MetricsRequest\":\n                        {\n                            if (processedRequestTypes.indexOf(request._tag) !== -1) continue;\n                            processedRequestTypes.push(request._tag);\n                            responses.push(metricsSnapshot());\n                            continue;\n                        }\n                }\n            }\n            var responsesToSend = responses.splice(0);\n            var notificationsToSend = notifications.splice(0);\n            return JSON.stringify({\n                responses: responsesToSend.concat(notificationsToSend),\n                instrumentationId: instrumentationId\n            });\n        }, getFiberCurrentSpanStack = function getFiberCurrentSpanStack(fiber) {\n            var spans = [];\n            if (!fiber || !fiber.currentSpan) return spans;\n            var current = fiber.currentSpan;\n            while(current){\n                spans.push({\n                    \"_tag\": current._tag,\n                    \"spanId\": current.spanId,\n                    \"traceId\": current.traceId,\n                    \"name\": current._tag === \"Span\" ? current.name : current.spanId,\n                    \"attributes\": current._tag === \"Span\" && current.attributes ? Array.from(current.attributes.entries()) : [],\n                    \"stack\": getSpanStack(current)\n                });\n                current = current._tag === \"Span\" && current.parent && current.parent._tag === \"Some\" ? current.parent.value : void 0;\n            }\n            return spans;\n        }, getFiberCurrentContext = function getFiberCurrentContext(fiber) {\n            if (!fiber) return [];\n            var _fiber__fiberRefs_locals_values;\n            return _to_consumable_array((_fiber__fiberRefs_locals_values = fiber._fiberRefs.locals.values()) !== null && _fiber__fiberRefs_locals_values !== void 0 ? _fiber__fiberRefs_locals_values : []).map(function(_) {\n                return _[0][1];\n            }).filter(function(_) {\n                return (typeof _ === \"undefined\" ? \"undefined\" : _type_of(_)) === \"object\" && _ !== null && Symbol.for(\"effect/Context\") in _;\n            }).flatMap(function(context) {\n                return _to_consumable_array(context.unsafeMap.entries());\n            });\n        }, getAliveFibers = function getAliveFibers() {\n            return fibers.map(function(fiber) {\n                return {\n                    \"id\": fiber.id().id.toString(),\n                    \"isCurrent\": fiber === globalThis[\"effect/FiberCurrent\"],\n                    \"isInterruptible\": fiber && \"currentRuntimeFlags\" in fiber && interruptible(fiber.currentRuntimeFlags)\n                };\n            });\n        };\n        var hasDevtoolsConnected = false;\n        var fibers = [];\n        var patchedTracers = [];\n        var addTracerInterceptorToFiber = function(fiber) {\n            var _fiber = fiber;\n            if (_fiber[\"effect/instrumentation/patchedCurrentTracer\"]) return;\n            _fiber[\"effect/instrumentation/patchedCurrentTracer\"] = true;\n            var previousTracer = fiber.currentTracer;\n            addSetInterceptor(fiber, \"currentTracer\", function(tracer) {\n                if (!tracer) return;\n                if (patchedTracers.indexOf(tracer) !== -1) return;\n                patchedTracers.push(tracer);\n                var _span = tracer.span.bind(tracer);\n                tracer.span = function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    var span = _span.apply(void 0, _to_consumable_array(args));\n                    try {\n                        pushNotification(convertSpan(span));\n                        var _event = span.event.bind(span);\n                        span.event = function(name, startTime, attributes) {\n                            for(var _len = arguments.length, args2 = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){\n                                args2[_key - 3] = arguments[_key];\n                            }\n                            var result = _event.apply(void 0, [\n                                name,\n                                startTime,\n                                attributes\n                            ].concat(_to_consumable_array(args2)));\n                            pushNotification({\n                                \"_tag\": \"SpanEvent\",\n                                \"spanId\": span.spanId,\n                                \"traceId\": span.traceId,\n                                \"name\": name,\n                                \"startTime\": String(startTime),\n                                \"attributes\": attributes || {}\n                            });\n                            return result;\n                        };\n                        var _end = span.end.bind(span);\n                        span.end = function() {\n                            for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n                                args2[_key] = arguments[_key];\n                            }\n                            var result = _end.apply(void 0, _to_consumable_array(args2));\n                            pushNotification(convertSpan(span));\n                            return result;\n                        };\n                    } catch (_) {}\n                    return span;\n                };\n            });\n            _fiber.currentTracer = previousTracer;\n        };\n        var responses = [];\n        var notifications = [];\n        var pushNotification = function(notification) {\n            notifications.push(notification);\n            if (notifications.length > 1e3) {\n                notifications.shift();\n            }\n        };\n        _globalThis[instrumentationKey] = {\n            \"fibers\": fibers,\n            \"debugProtocolDevtoolsClient\": debugProtocolDevtoolsClient,\n            \"getFiberCurrentSpanStack\": getFiberCurrentSpanStack,\n            \"getFiberCurrentContext\": getFiberCurrentContext,\n            \"getAliveFibers\": getAliveFibers\n        };\n        var _previousFiber = _globalThis[\"effect/FiberCurrent\"];\n        addSetInterceptor(_globalThis, \"effect/FiberCurrent\", function(_) {\n            if (_) addTrackedFiber(_);\n        });\n        _globalThis[\"effect/FiberCurrent\"] = _previousFiber;\n    }\n})();\n} )()"